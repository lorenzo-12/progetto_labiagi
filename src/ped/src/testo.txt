#include "utils.h"
#include "ros/ros.h"
#include "geometry_msgs/PoseStamped.h"
#include "/home/me/labiagi_2020_21/workspaces/srrg2_labiagi/devel/include/srrg2_core_ros/PlannerStatusMessage.h"

using namespace std;
geometry_msgs::PoseStamped goal;
string pacco;
int scelta=0;
list<utente> list_user;
string username;
string username_goal;
float pos_x;
float pos_y;
bool esiste=false;

void nulla(const std_msgs::String::ConstPtr& msg){
	//ROS_INFO("IL ROBOT HA SCRITTO: %s",msg->data.c_str());
}

int main(int argc, char** argv){
	//inizializzo il nodo e creo il nodehandle
	ros::init(argc, argv, "ped_client");
	ros::NodeHandle n;

	
	//publisher necessario per avvisare il robot che deve raggiungere un determinato goal
	ros::Publisher pub_goal = n.advertise<geometry_msgs::PoseStamped>("/move_base_simple/goal", 1000);
	
	ros::Subscriber sub_out = n.subscribe("/stato_robot", 1000, nulla);
	
	while(ros::ok()){
		
		cout << "COMANDI DISPONIBILI (0 PER TERMINARE):" << endl;
		cout << red;
		cout << "  1- INSERIMENTO/MODIFICA UTENTE NEL DATABASE" << endl;
		cout << fine;
		cout << blue;
		cout << "  2- RIMOZIONE UTENTE DAL DATABESE" << endl;
		cout << fine;
		cout << green;
		cout << "  3- PICK AND DELIVERY" << endl;
		cout << fine;
		cout << orange;
		cout << "  4- VISUALIZZAZIONE LISTA UTENTI" << endl << flush;
		cout << fine;
		cout << "DIGITARE LA FUNZIONE CHE SI DESIDERA ESEGUIRE: "; cin >> scelta;
		while(ros::ok() and (scelta>4 or scelta<0)){
			cout << "IL NUMERO INSERITO NON È VALIDO." << endl << "DIGITARE LA FUNZIONE CHE SI DESIDERA ESEGUIRE: "; 
			cin >> scelta;
		}
		if(scelta==0) return 0;
		
		else if(scelta==1){
			cout << "USERNAME: "; cin >> username;
			cout << "POSITION X: "; cin >> pos_x;
			cout << "POSITION Y: "; cin >> pos_y;
			int trovato=0;
			for(auto& k : list_user){
				if(k.name==username){
					trovato=1;
					k.x=pos_x;
					k.y=pos_y;
				}
			}
			if(trovato==1){
				cout << red;
				cout << "UTENTE GIÀ PRESENTE" << endl << flush;
				cout << fine;
			}
			else{
				utente tmp = utente(username,pos_x,pos_y);
				list_user.push_back(tmp);
				cout << red;
				cout << "UTENTE AGGIUNTO CORRETTAMENTE" << endl << flush;
				cout << fine;  
			}
			system("clear");
		}
		
		else if(scelta==2){
			cout << "USERNAME: "; cin >> username;
			for(auto k : list_user){
				if(k.name==username){
					pos_x=k.x;
					pos_y=k.y;
					break;
				}
			}
			utente k = utente(username,pos_x,pos_y);
			list_user.remove(k);
			system("clear");
		}
		
		else if(scelta==3){
			//chiedo in input all'utente le posizioni x e y che il robot deve raggiungere
			//e le inserisco all'interno del goal
			goal.header.frame_id="map";
			while(!esiste){	
				cout << "INSERIRE L'UTENTE A CUI SI INTENDE SPEDIRE IL PACCO: "; cin >> username_goal;
				for( auto k : list_user){
					if(k.name==username_goal){
						goal.pose.position.x=k.x;
						goal.pose.position.y=k.y;
						esiste=true;
						break;
					}
				}
				if(esiste==false){
					cout << "L'UTENTE INSERITO NON ESISTE NEL DATABASE, SI PREGA DI RIPROVARE." << endl << flush;
					cout << "INSERIRE L'UTENTE A CUI SI INTENDE SPEDIRE IL PACCO: "; cin >> username_goal;
				}
				
			}
			///cout << "x: "; cin >> goal.pose.position.x;
			///cout << "y: "; cin >> goal.pose.position.y;
			goal.header.stamp = ros::Time::now();
	
			//pubblico il goal sul topic "/move_base_simple/goal" in modo da far muovere il robot
			pub_goal.publish(goal);
	
			cout << lightblue;
			cout << "IL ROBOT È IN MOVIMENTO..." << endl << flush;
			cout << fine;
			ros::topic::waitForMessage<std_msgs::String>("/stato_robot",ros::Duration(120));
	
			cout << lightblue;
			cout << "IL ROBOT È ARRIVATO A DESTINAZIONE, INSERIRE IL PACCO" << endl << flush;
			cout << fine;
	
			while(ros::ok()){
				cout << "digita 'pacco' per inserirlo: "; cin >> pacco;
				if(pacco=="pacco") break; 
				cout << "messaggio non valido" << endl << flush;
			}
			cout << lightblue;
			cout << "PACCO INSERITO, DIGITARE ORA LA DESTINAZIONE" << endl << flush;
			cout << fine;
	
			esiste=false;
			while(!esiste){	
				cout << "INSERIRE L'UTENTE A CUI SI INTENDE SPEDIRE IL PACCO: "; cin >> username_goal;
				for( auto k : list_user){
					if(k.name==username_goal){
						goal.pose.position.x=k.x;
						goal.pose.position.y=k.y;
						esiste=true;
						break;
					}
				}
				if(esiste==false){
					cout << "L'UTENTE INSERITO NON ESISTE NEL DATABASE, SI PREGA DI RIPROVARE." << endl << flush;
					cout << "INSERIRE L'UTENTE A CUI SI INTENDE SPEDIRE IL PACCO: "; cin >> username_goal;
				}
				
			}
			
			goal.header.stamp = ros::Time::now();
			pub_goal.publish(goal);
	
			cout << lightblue;
			cout << "IL ROBOT È IN MOVIMENTO..." << endl << flush;
			cout << fine;
	
			ros::topic::waitForMessage<std_msgs::String>("/stato_robot",ros::Duration(120));
	
			cout << lightblue;
			cout << "IL PACCO È ARRIVATO A DESTINAZIONE." << endl << flush;
			cout << fine;
			ros::Duration(2,0).sleep();
			system("clear");
		}
		
		else if(scelta==4){
			cout << orange;
			cout << "LISTA UTENTI:" << endl << flush;
			cout << fine;
			for(auto k : list_user){
				cout << k.name << " " << k.x << " " << k.y << endl << flush;
			}
			cout << orange;
			cout << "---" << endl << flush;
			cout << fine;
		}
	}
	
	
	
	/// il momentaneo problema è che non so come fare per aspettare che il robot sia arrivato al goal, poichè quando provo
	/// ad usare funzioni come waitForMessage su un topic quello che succede è che è come se non venissero chiamate le
	/// funzioni di callback. allo stesso modo anche usando un ciclo while che aspetta fino a quando una variabile non 
	/// viene modificata non va poichè anche qui non vengon visualizzate le print presneti nella funzione di callback
	/// e quindi non viene eseguita tale funzione. non so come risovere questo problema devo chiedere al prof
	
	ros::spin();
	return 0;
}


///l'idea che mi era venuta in mente era quella di:
/// 1. chiedere all'utente le posizioni da far raggiungere al robot
/// 2. aspettare che il robot arrivi al punto stabilito
/// 3. aspettare che si riceva un messaggio (per segnalare che il pacco è stato messo)
/// 4. chiedere all'utente le coordinate dove il robot deve andare per spedire il pacco
/// 5. aspettare fino a quando il robot non raggiunge le coordinate inserite precedentemente
/// 6. aspettare che il pacco venga preso
/// 7.ripetere l'azione


//pre ora il problema principale sta nella realizzazione del punto 2. poichè non so come far aspettare un nodo. so farlo con le 
//so farlo usanod le actionlib ma non so farlo usando solamente i publisher e subscriber. 

//finchè non risolvo il punto 2- non posso andare avanti e fare i punti seguenti, poichè il punto 5 è identico al punto 2 e 
//il punto 7 implicherà cambiare delle cose ma si vedrà in seguito












#include "utils.h"
#include "ros/ros.h"
#include "geometry_msgs/PoseStamped.h"
#include "/home/me/labiagi_2020_21/workspaces/srrg2_labiagi/devel/include/srrg2_core_ros/PlannerStatusMessage.h"

using namespace std;
geometry_msgs::PoseStamped goal;
ros::Publisher pub_out;
std_msgs::String msg;
vector<float> v = {1,2,3,4};



//serve per inserire i valori della distanza allìinterno del vettore e fare in modo che tali valori 
//vengano inseriti in cerchio
int i=0;

//serve per tener traccia delle volte che è stata chiamata la funzione di callBack
int k=0; 

//rappresenta la distanza massima tra il punto di partenza del robot e il punto di arrivo
float dist=0;

//rappresenta la distanza del robot istante per istante
float dist_att=0;

//rappresenta la percentuale di completamento del percorso
int p=0;

bool sessione=false; //serve per far si che la funzione di callback "robot_status" venga eseguita solamente quando il robot sta 
				     //eseguendo un'azione
				    
				    
void stato_robot(const srrg2_core_ros::PlannerStatusMessage::ConstPtr& status){
	
	//la prima volta (per sessione) che viene chiamata la funzione si aspettano 2 secondi in modo da evitare che i precedenti
	//messaggi presenti sul topic vengano usati e mandino lo stato direttamente in FINITO
	if(k==0){
		ros::Duration(2, 0).sleep();
		sessione=true;
	}

	//siccome capita che tra i primi messaggi ci siano alcuni vecchi (con una distanza vicina allo zero) se nell/andare avanti
	//la distanza aumenta imposto la distanza totale del percorso al valore maggiore che ho ottenuto
	if(status->distance_to_global_goal>dist){
		dist=status->distance_to_global_goal;
	}
	
	//se non sono arrivato alla fine stampo dei valori tra cui la percentuale del cammino che si è fatto
	if(sessione){
		dist_att=dist-status->distance_to_global_goal;
		p=(dist_att/dist)*100;
		if(p<0) p=0;
		cout << "\rdist: " << setprecision(4) << dist << "  dist_att: "<< fixed << setprecision(4) << dist_att;
		cout << red;
		cout << "  completamento: " << p << "% " << flush;
		cout << fine;
	}
	
	//mi accorgo che sono arrivato alla fine del percorso perchè i valori della distanza del robot dal goal
	//pubblicati sul topic "/planner_status" smettono di variare, quindi nel momento in cui per 6 volte mi ritrovo la distanza 
	//sempre uguale considero che sono arrivato
	if(v.at(0)==v.at(1) and v.at(1)==v.at(2) and v.at(2)==v.at(3) and sessione){
		cout << "\rdist: " << setprecision(4) << dist << "  dist_att: "<< fixed << setprecision(4) << dist_att;
		cout << red;
		cout << "  completamento: 100%" << " " << flush;
		cout << fine;
		string s="robot arrivato";
		msg.data=s;
		cout << endl << flush;
		///cout << "invio la risposta" << endl << flush;
		pub_out.publish(msg);
		sessione=false;
		p=0; dist=0; dist_att=0; i=0;
		v = {1,2,3,4};
	}
	
	//ad ogni chiamata della funzione incremento le variabili e aggiungo nella prossiam posizione del vettore v il valore della
	//distanza, in modo che quando tutte e 6 le posizioni del vettore avranno lo stesso valore allora potrò considerare 
	//il robot arrivato al goal
	if(sessione){
		v.insert(v.begin()+i,status->distance_to_global_goal);
		k++;
		i++;
		i=i%4;
	}

	return;
}

void reset_sessione(const geometry_msgs::PoseStamped::ConstPtr& status){
	//cout << "HO RESETTATO LA SESSIONE" << endl << flush;
	k=0;
}

int main(int argc, char** argv){
	
	ros::init(argc, argv, "ped_test");
	ros::NodeHandle n;
	
	ros::Subscriber sub = n.subscribe("/move_base_simple/goal", 1000, reset_sessione);
	pub_out = n.advertise<std_msgs::String>("/stato_robot", 1000);
	
	//subscriber al topic /planner_status dove è presente la distanza del robot dal goal
	ros::Subscriber pub_status = n.subscribe("/planner_status", 1000, stato_robot);
	sessione=true;
	
	ros::spin();
	return 0;


}






































